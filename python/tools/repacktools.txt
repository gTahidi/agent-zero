================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-05T09:57:41.980Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
call_subordinate.py
code_execution_tool.py
knowledge_tool.py
memory_tool.py
online_knowledge_tool.py
response.py
task_done.py
unknown.py

================================================================
Repository Files
================================================================

================
File: call_subordinate.py
================
from agent import Agent
from python.helpers.tool import Tool, Response

class Delegation(Tool):

    def execute(self, message="", agent_name="", reset="", **kwargs):
        # Check if we need to create a new subordinate or reset the existing one
        if self.agent.get_data("subordinate") is None or str(reset).lower().strip() == "true":
            # Extract the current agent's number
            current_number = self.agent.number  # Use the existing number directly
            
            # Determine the new subordinate's number
            new_number = current_number + 1
            
            # Check if we've reached the delegation limit
            max_delegation = 5  # You can adjust this number as needed
            if new_number > max_delegation:
                return Response(
                    message="Maximum delegation depth reached. Cannot create more subordinates.",
                    break_loop=True
                )
            
            # Create the new subordinate agent with the correct number
            subordinate = Agent(new_number, self.agent.config)
            subordinate.set_data("superior", self.agent)
            self.agent.set_data("subordinate", subordinate)
        
        # Get the existing subordinate
        subordinate = self.agent.get_data("subordinate")
        
        # Delegate the task to the subordinate
        response = subordinate.message_loop(message)
        
        return Response(message=response, break_loop=False)

================
File: code_execution_tool.py
================
from dataclasses import dataclass
import shlex
from python.helpers import files
from python.helpers.tool import Tool, Response
from python.helpers.print_style import PrintStyle
from python.helpers.docker import DockerContainerManager

@dataclass
class State:
    docker: DockerContainerManager | None

class CodeExecution(Tool):
    def execute(self, **kwargs):
        """
        Execute a code snippet in a specific runtime environment.

        Available runtime environments are 'python', 'nodejs', and 'terminal'.

        If the runtime environment is not specified, the default is 'python'.

        The code to be executed should be passed as a string in the 'code' argument.

        The output of the code execution is returned as a string in the response.

        If the code execution results in an error, the error message is returned
        as the output.

        If the code execution results in no output, a default message is returned
        as the output.

        :param runtime: The runtime environment to use. Default is 'python'.
        :type runtime: str
        :param code: The code to be executed.
        :type code: str
        :return: The output of the code execution.
        :rtype: str
        """
        if self.agent.handle_intervention():
            return Response(message="", break_loop=False)

        self.prepare_state()

        runtime = self.args["runtime"].lower().strip()
        code = self.args["code"]

        if runtime == "python":
            command = f'python3 -c {shlex.quote(code)}'
        elif runtime == "nodejs":
            command = f'node -e {shlex.quote(code)}'
        elif runtime == "terminal":
            command = code
        else:
            return Response(message=files.read_file("./prompts/fw.code_runtime_wrong.md", runtime=runtime), break_loop=False)

        output = self.state.docker.execute_command(command)
        
        if not output:
            output = files.read_file("./prompts/fw.code_no_output.md")

        return Response(message=output, break_loop=False)

    def after_execution(self, response, **kwargs):
        """
        Print the response from code execution to the agent's message list.

        :param response: The response from code execution.
        :type response: Response
        :param **kwargs: Additional keyword arguments.
        :type **kwargs: dict
        """
        msg_response = files.read_file("./prompts/fw.tool_response.md", tool_name=self.name, tool_response=response.message)
        self.agent.append_message(msg_response, human=True)

    def prepare_state(self):
        
        """
        Prepare the state of the code execution tool.

        This function is called every time the code execution tool is executed.
        It checks if the state of the tool is already stored in the agent's data.
        If not, it creates the state.

        :return: None
        :rtype: None
        """
        self.state = self.agent.get_data("cot_state")
        if not self.state:
            if self.agent.config.code_exec_docker_enabled:
                docker = DockerContainerManager(
                    name=self.agent.config.code_exec_docker_name,
                    image=self.agent.config.code_exec_docker_image,
                    ports=self.agent.config.code_exec_docker_ports,
                    volumes=self.agent.config.code_exec_docker_volumes
                )
                docker.start_container()
            else:
                docker = None

            self.state = State(docker=docker)
        self.agent.set_data("cot_state", self.state)

================
File: knowledge_tool.py
================
import os
from agent import Agent
from . import online_knowledge_tool
from python.helpers import perplexity_search
from python.helpers import duckduckgo_search

from . import memory_tool
import concurrent.futures

from python.helpers.tool import Tool, Response
from python.helpers import files
from python.helpers.print_style import PrintStyle

class Knowledge(Tool):
    def execute(self, question="", **kwargs):
        with concurrent.futures.ThreadPoolExecutor() as executor:
            # Schedule the two functions to be run in parallel

            # perplexity search, if API provided
            if os.getenv("API_KEY_PERPLEXITY"):
                perplexity = executor.submit(perplexity_search.perplexity_search, question)
            else: 
                PrintStyle.hint("No API key provided for Perplexity. Skipping Perplexity search.")
                perplexity = None
                

            # duckduckgo search
            duckduckgo = executor.submit(duckduckgo_search.search, question)

            # memory search
            future_memory = executor.submit(memory_tool.search, self.agent, question)

            # Wait for both functions to complete
            perplexity_result = (perplexity.result() if perplexity else "") or ""
            duckduckgo_result = duckduckgo.result()
            memory_result = future_memory.result()

        msg = files.read_file("prompts/tool.knowledge.response.md", 
                              online_sources = perplexity_result + "\n\n" + str(duckduckgo_result),
                              memory = memory_result )

        if self.agent.handle_intervention(msg): pass # wait for intervention and handle it, if paused

        return Response(message=msg, break_loop=False)

================
File: memory_tool.py
================
import re
from agent import Agent
from python.helpers.vector_db import VectorDB, Document
from python.helpers import files
import os, json
from python.helpers.tool import Tool, Response
from python.helpers.print_style import PrintStyle
from chromadb.errors import InvalidDimensionException

# TODO multiple DBs at once
db: VectorDB | None= None

class Memory(Tool):
    def execute(self,**kwargs):
        result=""
        
        try:
            if "query" in kwargs:
                threshold = float(kwargs.get("threshold", 0.1))
                count = int(kwargs.get("count", 5))
                result = search(self.agent, kwargs["query"], count, threshold)
            elif "memorize" in kwargs:
                result = save(self.agent, kwargs["memorize"])
            elif "forget" in kwargs:
                result = forget(self.agent, kwargs["forget"])
            elif "delete" in kwargs:
                result = delete(self.agent, kwargs["delete"])
        except InvalidDimensionException as e:
            # hint about embedding change with existing database
            PrintStyle.hint("If you changed your embedding model, you will need to remove contents of /memory directory.")
            raise   
        
        # result = process_query(self.agent, self.args["memory"],self.args["action"], result_count=self.agent.config.auto_memory_count)
        return Response(message=result, break_loop=False)
            
def search(agent:Agent, query:str, count:int=5, threshold:float=0.1):
    initialize(agent)
    docs = db.search_similarity_threshold(query,count,threshold) # type: ignore
    if len(docs)==0: return files.read_file("./prompts/fw.memories_not_found.md", query=query)
    else: return str(docs)

def save(agent:Agent, text:str):
    initialize(agent)
    id = db.insert_document(text) # type: ignore
    return files.read_file("./prompts/fw.memory_saved.md", memory_id=id)

def delete(agent:Agent, ids_str:str):
    initialize(agent)
    ids = extract_guids(ids_str)
    deleted = db.delete_documents_by_ids(ids) # type: ignore
    return files.read_file("./prompts/fw.memories_deleted.md", memory_count=deleted)    

def forget(agent:Agent, query:str):
    initialize(agent)
    deleted = db.delete_documents_by_query(query) # type: ignore
    return files.read_file("./prompts/fw.memories_deleted.md", memory_count=deleted)

def initialize(agent:Agent):
    global db
    if not db:
        dir = os.path.join("memory",agent.config.memory_subdir)
        db = VectorDB(embeddings_model=agent.config.embeddings_model, in_memory=False, cache_dir=dir)

def extract_guids(text):
    pattern = r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}\b'
    return re.findall(pattern, text)

================
File: online_knowledge_tool.py
================
from agent import Agent
from python.helpers import perplexity_search
from python.helpers.tool import Tool, Response

class OnlineKnowledge(Tool):
    def execute(self,**kwargs):
        return Response(
            message=process_question(self.args["question"]),
            break_loop=False,
        )

def process_question(question):
    return str(perplexity_search.perplexity_search(question))

================
File: response.py
================
from agent import Agent
from python.helpers import files
from python.helpers.print_style import PrintStyle

from agent import Agent
from python.helpers.tool import Tool, Response
from python.helpers import files
from python.helpers.print_style import PrintStyle

class ResponseTool(Tool):

    def execute(self,**kwargs):
        self.agent.set_data("timeout", self.agent.config.response_timeout_seconds)
        return Response(message=self.args["text"], break_loop=True)

    def before_execution(self, **kwargs):
        pass # do not add anything to the history or output
    
    def after_execution(self, response, **kwargs):
        pass # do not add anything to the history or output

================
File: task_done.py
================
from agent import Agent
from python.helpers import files
from python.helpers.print_style import PrintStyle

from agent import Agent
from python.helpers.tool import Tool, Response
from python.helpers import files
from python.helpers.print_style import PrintStyle

class TaskDone(Tool):

    def execute(self,**kwargs):
        self.agent.set_data("timeout", 0)
        return Response(message=self.args["text"], break_loop=True)

    def before_execution(self, **kwargs):
        pass # do not add anything to the history or output
    
    def after_execution(self, response, **kwargs):
        pass # do add anything to the history or output

================
File: unknown.py
================
from python.helpers.tool import Tool, Response
from python.helpers import files

class Unknown(Tool):
    def execute(self, **kwargs):
        return Response(
                message=files.read_file("prompts/fw.tool_not_found.md",
                                        tool_name=self.name,
                                        tools_prompt=files.read_file("prompts/agent.tools.md")), 
                break_loop=False)
